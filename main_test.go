//go:build !ci

package main

import (
	"os"
	"os/exec"
	"testing"
	"time"
)

// TestMainRuns проверяет, что функция main может быть запущена и проработать
// некоторое время без паники. Это стандартный подход для тестирования main-функций,
// которые запускают долгоживущие процессы (например, серверы или графические приложения).
func TestMainRuns(t *testing.T) {
	// Мы запускаем тест в дочернем процессе, чтобы иметь возможность его контролировать.
	// Переменная окружения BE_THE_GAME используется, чтобы отличить дочерний процесс
	// от основного процесса теста.
	if os.Getenv("BE_THE_GAME") == "1" {
		main()
		return
	}

	// Запускаем новый процесс, который выполнит этот же тест, но с установленной
	// переменной окружения. os.Args[0] - это путь к текущему тестовому бинарнику.
	cmd := exec.Command(os.Args[0], "-test.run=TestMainRuns")
	cmd.Env = append(os.Environ(), "BE_THE_GAME=1")

	// Стартуем процесс.
	err := cmd.Start()
	if err != nil {
		t.Fatalf("не удалось запустить команду: %v", err)
	}

	// Даем приложению поработать 1 секунду. Если за это время произойдет
	// паника, процесс завершится с ошибкой, и мы это обнаружим.
	done := make(chan error)
	go func() {
		done <- cmd.Wait()
	}()

	select {
	case <-time.After(1 * time.Second):
		// Время вышло, и процесс все еще работает. Это ожидаемое поведение.
		// Теперь мы должны его остановить.
		err := cmd.Process.Kill()
		if err != nil {
			t.Fatalf("не удалось завершить процесс: %v", err)
		}
	case err := <-done:
		// Процесс завершился раньше времени. Это означает ошибку.
		if err != nil {
			t.Fatalf("процесс завершился с ошибкой: %v", err)
		}
	}
}